---
- name: Install PostgreSQL with Patroni HA
  hosts: postgres_nodes
  become: true
  vars:
    postgresql_version: "17"
    patroni_version: "4.0.6"
    postgres_version: "17"
    postgres_port: 5432
    patroni_rest_api_port: 8008
    consul_client_port: 8500
    postgres_password: "{{ vault_postgres_password }}"
    postgres_replication_password: "{{ vault_postgres_replication_password }}"
    postgres_user: "postgres"
    postgres_db_name: "proposalsapp"
    # Resource settings - adjust based on server RAM
    postgres_shared_buffers: "2GB"
    postgres_effective_cache_size: "6GB"
    postgres_work_mem: "16MB"

  tasks:
    - name: Set connection to use tailscale IP if available
      set_fact:
        ansible_host: "{{ tailscale_ip }}"
      when: tailscale_ip is defined and tailscale_ip != ''
    
    # Pre-flight check: Ensure Consul is properly federated
    - name: Verify Consul WAN federation
      shell: |
        # Check if Consul can see all datacenters
        datacenters=$(consul catalog datacenters | wc -l)
        expected_dcs={{ groups['lxc_containers'] | select('match', '^consul-nomad-') | map('extract', hostvars, 'datacenter') | unique | list | length }}
        
        if [ "$datacenters" -lt "$expected_dcs" ]; then
          echo "ERROR: Consul federation incomplete. Found $datacenters datacenters, expected $expected_dcs"
          echo "Available datacenters:"
          consul catalog datacenters
          exit 1
        fi
        
        echo "OK: Consul federation verified across $datacenters datacenters"
      register: consul_federation
      changed_when: false
      run_once: true
      delegate_to: "{{ groups['consul_servers'][0] }}"
    - name: Add PostgreSQL APT key
      apt_key:
        url: https://www.postgresql.org/media/keys/ACCC4CF8.asc
        state: present

    - name: Add PostgreSQL repository
      apt_repository:
        repo: "deb http://apt.postgresql.org/pub/repos/apt {{ ansible_distribution_release }}-pgdg main"
        state: present

    - name: Install PostgreSQL and dependencies
      apt:
        name:
          - "postgresql-{{ postgresql_version }}"
          - "postgresql-contrib-{{ postgresql_version }}"
          - "postgresql-{{ postgresql_version }}-repack"
          - python3-pip
          - python3-psycopg2
          - python3-etcd
          - libpq-dev
        state: present

    - name: Check if Patroni service exists
      systemd:
        name: patroni
      register: patroni_service_check
      failed_when: false

    - name: Stop Patroni service if running
      systemd:
        name: patroni
        state: stopped
      when: patroni_service_check.status.ActiveState is defined and patroni_service_check.status.ActiveState == "active"

    - name: Check PostgreSQL service status
      systemd:
        name: postgresql
      register: postgresql_service
      failed_when: false

    - name: Stop PostgreSQL service
      systemd:
        name: postgresql
        state: stopped
        enabled: no
      when: postgresql_service.status.ActiveState is defined and postgresql_service.status.ActiveState == "active"

    - name: Install pipx and venv support
      apt:
        name:
          - pipx
          - python3-venv
          - python3-full
        state: present

    - name: Check if Patroni is already installed
      stat:
        path: /var/lib/postgresql/.local/bin/patroni
      register: patroni_installed

    - name: Install Patroni and dependencies for postgres user
      shell: |
        su - postgres -c '
        export PATH="/usr/bin:$PATH"
        pipx install "patroni[consul]=={{ patroni_version }}" --include-deps
        pipx inject patroni psycopg2-binary python-consul cdiff
        '
      when: not patroni_installed.stat.exists

    - name: Ensure Patroni has all dependencies
      shell: |
        su - postgres -c '
        export PATH="/usr/bin:$PATH"
        pipx inject patroni cdiff --force
        '
      when: patroni_installed.stat.exists

    - name: Create Patroni configuration directory
      file:
        path: /etc/patroni
        state: directory
        mode: "0755"

    - name: Ensure PostgreSQL data directory is clean for fresh install
      file:
        path: /var/lib/postgresql/{{ postgresql_version }}/data
        state: absent

    - name: Create PostgreSQL data directory
      file:
        path: /var/lib/postgresql/{{ postgresql_version }}/data
        state: directory
        owner: postgres
        group: postgres
        mode: "0700"



    - name: Generate Patroni configuration
      template:
        src: ../templates/patroni.yml.j2
        dest: /etc/patroni/patroni.yml
        owner: postgres
        group: postgres
        mode: "0640"
    
    - name: Generate Patroni bootstrap SQL script
      template:
        src: ../templates/patroni-bootstrap.sql.j2
        dest: /tmp/patroni-bootstrap.sql
        owner: postgres
        group: postgres
        mode: "0644"
    
    - name: Generate Patroni post-init wrapper script
      template:
        src: ../templates/patroni-post-init.sh.j2
        dest: /tmp/patroni-post-init.sh
        owner: postgres
        group: postgres
        mode: "0755"

    - name: Create Patroni systemd service
      copy:
        content: |
          [Unit]
          Description=Patroni PostgreSQL HA
          After=syslog.target network.target consul.service
          Wants=consul.service

          [Service]
          Type=simple
          User=postgres
          Group=postgres
          Environment="PATH=/var/lib/postgresql/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
          ExecStart=/var/lib/postgresql/.local/bin/patroni /etc/patroni/patroni.yml
          ExecReload=/bin/kill -s HUP $MAINPID
          KillMode=process
          TimeoutSec=30
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/patroni.service
      notify:
        - reload systemd
        - restart patroni

    # Clean any existing Patroni state to ensure fresh start
    - name: Clean existing Patroni state from all datacenters
      uri:
        url: "http://localhost:{{ consul_client_port }}/v1/kv/service/proposalsapp?recurse=true"
        method: DELETE
        status_code: [200, 404]
      run_once: true
      delegate_to: "{{ groups['consul_servers'][0] }}"

    - name: Wait for consul-replicate to sync the cleanup
      pause:
        seconds: 10
        prompt: "Waiting for consul-replicate to propagate cleanup across datacenters"
      run_once: true

    # Start nodes in order to ensure proper cluster formation
    - name: Start Patroni on designated primary node first
      systemd:
        name: patroni
        state: started
        enabled: yes
      when: postgres_role == 'primary'

    - name: Wait for primary to initialize cluster
      pause:
        seconds: 30
        prompt: "Waiting for primary to initialize and register in Consul"
      when: postgres_role == 'primary'
    
    - name: Create wait script for Patroni initialization
      template:
        src: ../templates/wait-for-patroni.sh.j2
        dest: /tmp/wait-for-patroni.sh
        mode: "0755"
      when: postgres_role == 'primary'
    
    - name: Wait for Patroni to fully initialize the database
      shell: /tmp/wait-for-patroni.sh
      when: postgres_role == 'primary'
      register: postgres_ready_check

    - name: Wait for consul-replicate to sync initial cluster state
      pause:
        seconds: 30
        prompt: "Waiting for consul-replicate to propagate cluster state to all datacenters"
      run_once: true
    
    - name: Ensure required PostgreSQL roles exist  
      environment:
        PGPASSWORD: "{{ postgres_password }}"
      shell: |
        # Check if proposalsapp role exists, create if not
        if ! psql -h localhost -U postgres -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='proposalsapp';" | grep -q 1; then
          echo "Creating proposalsapp role..."
          psql -h localhost -U postgres -d postgres -f /tmp/patroni-bootstrap.sql
        else
          echo "Role proposalsapp already exists"
        fi
        
        # Verify roles were created
        echo "Current roles:"
        psql -h localhost -U postgres -d postgres -c "SELECT rolname FROM pg_roles WHERE rolname IN ('proposalsapp', 'replicator');"
      when: postgres_role == 'primary'
      run_once: true
      register: role_creation

    - name: Verify initialize key is replicated to all datacenters
      shell: |
        #!/bin/bash
        set -e
        
        # Check if the initialize key exists in dc1
        CONSUL_PORT=8500
        
        echo "Checking for initialize key in primary datacenter..."
        dc1_response=$(curl -s "http://localhost:${CONSUL_PORT}/v1/kv/service/proposalsapp/initialize?dc=dc1")
        
        if [ -z "$dc1_response" ] || [ "$dc1_response" = "null" ]; then
          echo "ERROR: No initialize key found in primary datacenter"
          exit 1
        fi
        
        # Get the key index from dc1
        dc1_index=$(echo "$dc1_response" | jq -r '.[0].ModifyIndex')
        echo "Primary datacenter has initialize key with index: $dc1_index"
        
        # Check all datacenters have the initialize key
        for dc in dc2 dc3; do
          echo "Checking datacenter $dc..."
          dc_response=$(curl -s "http://localhost:${CONSUL_PORT}/v1/kv/service/proposalsapp/initialize?dc=$dc")
          
          if [ -z "$dc_response" ] || [ "$dc_response" = "null" ]; then
            echo "ERROR: Datacenter $dc missing initialize key"
            exit 1
          fi
          
          dc_index=$(echo "$dc_response" | jq -r '.[0].ModifyIndex')
          echo "Datacenter $dc has initialize key with index: $dc_index"
        done
        
        echo "SUCCESS: All datacenters have the initialize key"
      args:
        executable: /bin/bash
      register: dc_sync_check
      until: dc_sync_check.rc == 0
      retries: 30
      delay: 5
      run_once: true
      delegate_to: "{{ groups['consul_servers'][0] }}"

    - name: Verify initialize key is available locally before starting standby
      shell: |
        # Check if the initialize key exists in local Consul
        init_value=$(curl -s http://localhost:{{ consul_client_port }}/v1/kv/service/proposalsapp/initialize?raw)
        
        if [ -z "$init_value" ]; then
          echo "ERROR: Initialize key not found in local Consul ({{ datacenter }})"
          echo "consul-replicate may not have synced yet"
          exit 1
        fi
        
        echo "Found initialize value in {{ datacenter }}: $init_value"
      register: local_init_check
      until: local_init_check.rc == 0
      retries: 60
      delay: 5
      when: postgres_role != 'primary'

    - name: Start Patroni on standby nodes
      systemd:
        name: patroni
        state: started
        enabled: yes
      when: postgres_role != 'primary'

    - name: Wait for all nodes to stabilize
      pause:
        seconds: 20
      run_once: true

    - name: Verify cluster has formed with leader
      shell: |
        # Check for leader in the cluster
        i=1
        while [ $i -le 30 ]; do
          if /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list 2>&1 | grep -q "Leader"; then
            echo "Cluster has a leader"
            /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list
            exit 0
          fi
          sleep 2
          i=$((i + 1))
        done
        echo "ERROR: No leader elected"
        exit 1
      run_once: true
      delegate_to: db-sib-01  # Check from primary DC
      register: leader_check

    - name: Wait for all nodes to join cluster
      shell: |
        # Wait for this node to appear in the cluster
        i=1
        while [ $i -le 90 ]; do
          cluster_output=$(/var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list 2>&1)
          
          # Check if this node appears in the cluster output
          if echo "$cluster_output" | grep -q "{{ inventory_hostname }}"; then
            # Also check if the node is in a good state (running or streaming)
            if echo "$cluster_output" | grep "{{ inventory_hostname }}" | grep -qE "(running|streaming)"; then
              echo "Node joined cluster successfully and is in good state"
              echo "$cluster_output"
              exit 0
            else
              echo "Node is in cluster but not yet in good state, waiting... (attempt $i/90)"
            fi
          else
            echo "Waiting for node to join cluster... (attempt $i/90)"
          fi
          sleep 2
          i=$((i + 1))
        done
        echo "ERROR: Failed to join cluster or reach good state after 180 seconds"
        echo "Final Patroni status:"
        /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list 2>&1 || true
        echo ""
        echo "Patroni service status:"
        systemctl status patroni --no-pager || true
        echo ""
        echo "Last 50 lines of Patroni log:"
        journalctl -u patroni -n 50 --no-pager || true
        exit 1
      register: node_join
      failed_when: node_join.rc != 0

    - name: Check if PostgreSQL service is already registered
      uri:
        url: "http://localhost:{{ consul_client_port }}/v1/agent/service/postgres-{{ inventory_hostname }}"
        method: GET
        status_code: [200, 404]
      register: postgres_service_check
      changed_when: false

    - name: Register PostgreSQL services in Consul
      uri:
        url: "http://localhost:{{ consul_client_port }}/v1/agent/service/register"
        method: PUT
        body_format: json
        body:
          ID: "postgres-{{ inventory_hostname }}"
          Name: "postgres"
          Tags:
            - "{{ postgres_role }}"
            - "{{ datacenter }}"
          Port: 5432
          Check:
            TCP: "localhost:5432"
            Interval: "10s"
      when: postgres_service_check.status == 404

    - name: Wait for PostgreSQL to be ready
      wait_for:
        port: 5432
        host: localhost
        delay: 5
        timeout: 60


    - name: Store PostgreSQL connection details in Consul KV
      uri:
        url: "http://localhost:{{ consul_client_port }}/v1/kv/{{ item.key }}"
        method: PUT
        body: "{{ item.value }}"
      loop:
        - { key: "postgresql/primary_host", value: "{{ inventory_hostname }}" }
        - { key: "postgresql/primary_tailscale_ip", value: "{{ tailscale_ip }}" }
        - { key: "postgresql/port", value: "5432" }
        - { key: "postgresql/database", value: "{{ postgres_db_name }}" }
        - { key: "postgresql/username", value: "proposalsapp" }
        - { key: "postgresql/admin_username", value: "{{ postgres_user }}" }
        - { key: "postgresql/password", value: "{{ postgres_password }}" }
        - { key: "postgresql/service_discovery", value: "proposalsapp.service.consul" }
        - { key: "postgresql/connection_string/consul", value: "postgresql://proposalsapp:{{ postgres_password }}@proposalsapp.service.consul:5432/{{ postgres_db_name }}" }
        - { key: "postgresql/connection_string/hostname", value: "postgresql://proposalsapp:{{ postgres_password }}@{{ inventory_hostname }}:5432/{{ postgres_db_name }}" }
        - { key: "postgresql/connection_string/tailscale_ip", value: "postgresql://proposalsapp:{{ postgres_password }}@{{ tailscale_ip }}:5432/{{ postgres_db_name }}" }
        - { key: "database/name", value: "{{ postgres_db_name }}" }
        - { key: "database/user", value: "proposalsapp" }
        - { key: "database/password", value: "{{ postgres_password }}" }
      run_once: true
      when: postgres_role == 'primary'

    - name: Wait for all PostgreSQL nodes to join cluster
      pause:
        seconds: 30
      run_once: true

    - name: Verify all nodes are in cluster before configuring replication
      shell: |
        # Get the expected number of nodes
        expected_nodes="{{ groups['postgres_nodes'] | length }}"
        
        # Count actual nodes in cluster
        actual_nodes=$(/var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list | grep -E "Leader|Replica" | wc -l)
        
        echo "Expected nodes: $expected_nodes, Actual nodes: $actual_nodes"
        
        if [ "$actual_nodes" -eq "$expected_nodes" ]; then
          echo "All nodes are in the cluster"
          exit 0
        else
          echo "WARNING: Not all nodes have joined the cluster yet"
          exit 1
        fi
      register: cluster_check
      until: cluster_check.rc == 0
      retries: 10
      delay: 10
      when: postgres_role == 'primary'
      run_once: true

    - name: Configure synchronous replication with proper standby names
      shell: |
        # Get list of standby nodes from the cluster
        standby_nodes=$(/var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list | grep "Replica" | awk '{print $2}' | tr '\n' ',' | sed 's/,$//')
        
        if [ -n "$standby_nodes" ]; then
          echo "Found standby nodes: $standby_nodes"
          
          # Count replicas
          replica_count=$(echo "$standby_nodes" | tr ',' '\n' | wc -l)
          
          # Build synchronous_standby_names based on datacenter distribution
          # Use ANY 1 syntax for quorum-based replication
          sync_standby_names="ANY 1 ($standby_nodes)"
          
          echo "Enabling synchronous replication with: $sync_standby_names"
          
          # Enable synchronous mode in Patroni
          /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml edit-config \
            -s "synchronous_mode=true" \
            -s "synchronous_mode_strict=false" \
            -s "postgresql.parameters.synchronous_commit=remote_apply" \
            -s "postgresql.parameters.synchronous_standby_names='$sync_standby_names'" \
            --force
          
          echo "Synchronous replication enabled with $replica_count replicas"
        else
          echo "No replicas found, keeping synchronous mode disabled"
          
          # Ensure async parameters are set
          /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml edit-config \
            -s "synchronous_mode=false" \
            -s "postgresql.parameters.synchronous_commit=on" \
            -s "postgresql.parameters.synchronous_standby_names=" \
            --force
        fi
      register: sync_result
      changed_when: "'Synchronous replication enabled' in sync_result.stdout"
      run_once: true
      when: postgres_role == 'primary'

    - name: Wait for database initialization to complete
      pause:
        seconds: 10
      when: postgres_role == 'primary'

    - name: Check if this node is the leader
      shell: |
        /var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list | grep "{{ inventory_hostname }}" | grep -q "Leader"
      register: is_leader
      failed_when: false
      changed_when: false

    - name: Create application database on leader node
      shell: |
        export PGPASSWORD="{{ postgres_password }}"
        
        # First check if we can connect as postgres user
        if ! psql -h localhost -U postgres -d postgres -c "SELECT 1;" >/dev/null 2>&1; then
          echo "ERROR: Cannot connect to PostgreSQL as postgres user"
          exit 1
        fi
        
        # Ensure proposalsapp role exists before creating database
        if ! psql -h localhost -U postgres -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='proposalsapp';" | grep -q 1; then
          echo "Creating proposalsapp role first..."
          psql -h localhost -U postgres -d postgres -c "CREATE ROLE proposalsapp WITH LOGIN PASSWORD '{{ postgres_password }}' CREATEDB CREATEROLE;"
        fi
        
        # Check if database already exists
        if psql -h localhost -U postgres -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='proposalsapp';" | grep -q 1; then
          echo "Database proposalsapp already exists"
          # Ensure proposalsapp can connect
          export PGPASSWORD="{{ postgres_password }}"
          if psql -h localhost -U proposalsapp -d proposalsapp -c "SELECT 1;" >/dev/null 2>&1; then
            echo "Database exists and is accessible"
            exit 0
          else
            echo "Database exists but proposalsapp cannot connect, granting permissions..."
            export PGPASSWORD="{{ postgres_password }}"
            psql -h localhost -U postgres -d proposalsapp -c "GRANT ALL PRIVILEGES ON DATABASE proposalsapp TO proposalsapp;"
            psql -h localhost -U postgres -d proposalsapp -c "GRANT ALL ON SCHEMA public TO proposalsapp;"
          fi
        else
          # Create the database
          echo "Creating database proposalsapp..."
          psql -h localhost -U postgres -c "CREATE DATABASE proposalsapp OWNER proposalsapp ENCODING 'UTF8';"
        fi
        
        # Verify connection as proposalsapp user
        export PGPASSWORD="{{ postgres_password }}"
        if ! psql -h localhost -U proposalsapp -d proposalsapp -c "SELECT version();" >/dev/null 2>&1; then
          echo "ERROR: Cannot connect as proposalsapp user to new database"
          exit 1
        fi
        
        echo "SUCCESS: Database created and verified"
      when: is_leader.rc == 0  # Only run on the actual leader
      register: db_create
      retries: 5
      delay: 10
      until: db_create.rc == 0

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes

    - name: restart patroni
      systemd:
        name: patroni
        state: restarted


# Verification checks at the end
- name: Verify PostgreSQL Cluster
  hosts: postgres_nodes
  gather_facts: false
  vars:
    postgres_user: "postgres"
    postgres_db_name: "proposalsapp"
    postgres_password: "{{ vault_postgres_password }}"
    consul_client_port: 8500
  tasks:
    - name: Wait for PostgreSQL to stabilize
      pause:
        seconds: 15

    - name: Check Patroni service health
      shell: |
        # Check if Patroni is running
        if ! systemctl is-active patroni >/dev/null 2>&1; then
          echo "ERROR: Patroni service is not running"
          exit 1
        fi

        echo "OK: Patroni service is active"
      register: patroni_health
      changed_when: false
      failed_when: patroni_health.rc != 0

    - name: Check Patroni cluster status
      shell: |
        # Check Patroni cluster status
        cluster_info=$(/var/lib/postgresql/.local/bin/patronictl -c /etc/patroni/patroni.yml list 2>&1)
        if [ $? -ne 0 ]; then
          echo "ERROR: Cannot query Patroni cluster: $cluster_info"
          exit 1
        fi

        # Check if this node is in the cluster
        if ! echo "$cluster_info" | grep -q "{{ inventory_hostname }}"; then
          echo "ERROR: This node is not in the Patroni cluster"
          echo "$cluster_info"
          exit 1
        fi

        # Check for a leader (but allow time for election during initial setup)
        if ! echo "$cluster_info" | grep -q -E "(Leader|initializing)"; then
          echo "ERROR: No leader in Patroni cluster and not initializing"
          echo "$cluster_info"
          exit 1
        fi

        echo "OK: Patroni cluster healthy"
        echo "$cluster_info"
      register: patroni_cluster
      changed_when: false
      failed_when: patroni_cluster.rc != 0

    - name: Check PostgreSQL connectivity
      shell: |
        export PGPASSWORD="{{ postgres_password }}"
        if ! psql -h localhost -U {{ postgres_user }} -d postgres -c "SELECT version();" >/dev/null 2>&1; then
          echo "ERROR: Cannot connect to PostgreSQL"
          exit 1
        fi

        echo "OK: PostgreSQL is accessible"
      register: postgres_connectivity
      changed_when: false
      failed_when: postgres_connectivity.rc != 0

    - name: Verify Consul service registration
      shell: |
        # Check if PostgreSQL service is registered in Consul
        service_info=$(curl -s http://localhost:{{ consul_client_port }}/v1/agent/service/postgres-{{ inventory_hostname }})
        if [ $? -ne 0 ] || [ -z "$service_info" ] || [ "$service_info" = "null" ]; then
          echo "ERROR: PostgreSQL service not registered in Consul"
          exit 1
        fi

        echo "OK: PostgreSQL service registered in Consul"
        echo "$service_info" | jq -r '.ID + " - " + .Service + " - Port: " + (.Port|tostring)'
      register: consul_service
      changed_when: false
      failed_when: consul_service.rc != 0

    - name: Display PostgreSQL verification summary
      debug:
        msg: |
          ========================================
          PostgreSQL Cluster Verification Summary
          ========================================
          Node: {{ inventory_hostname }}
          Patroni Status: {{ 'RUNNING' if patroni_health.rc == 0 else 'FAILED' }}
          Cluster Health: {{ 'HEALTHY' if patroni_cluster.rc == 0 else 'UNHEALTHY' }}
          PostgreSQL Access: {{ 'OK' if postgres_connectivity.rc == 0 else 'FAILED' }}
          Consul Registration: {{ 'REGISTERED' if consul_service.rc == 0 else 'NOT REGISTERED' }}

          Cluster Status:
          {{ patroni_cluster.stdout | indent(2) }}

          Connection Details:
          - Direct PostgreSQL: {{ inventory_hostname }}:5432
          - Database: {{ postgres_db_name }}
          - Note: Applications should connect via PgCat on localhost:5432
          - User: {{ postgres_user }}
          ========================================

- name: Display Overall Cluster Summary
  hosts: postgres_nodes[0]
  gather_facts: false
  tasks:
    - name: Get full cluster overview
      shell: |
        echo "=== PATRONI CLUSTER OVERVIEW ==="
        patronictl -c /etc/patroni/patroni.yml list
        echo ""
        echo "=== REPLICATION STATUS ==="
        export PGPASSWORD="{{ postgres_password }}"
        psql -h localhost -U {{ postgres_user }} -d postgres -c "SELECT client_addr, state, sync_state FROM pg_stat_replication;" 2>/dev/null || echo "No replicas (this might be a replica node)"
      register: cluster_overview
      changed_when: false

    - name: Display cluster overview
      debug:
        msg: |
          ========================================
          PostgreSQL HA Cluster Overview
          ========================================
          {{ cluster_overview.stdout }}
          ========================================
