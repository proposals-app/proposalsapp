---
- name: Install etcd for Patroni in multi-DC WAN federated setup
  hosts: postgres_nodes
  become: true
  vars:
    etcd_version: "3.5.16" # Using latest 3.5.x as 3.6 might have breaking changes
    etcd_client_port: 2379
    etcd_peer_port: 2380
    etcd_data_dir: "/var/lib/etcd"
    etcd_wal_dir: "/var/lib/etcd/wal"
    etcd_user: "etcd"
    etcd_group: "etcd"
    # Network tuning for WAN
    etcd_ionice_class: "2" # Best effort I/O
    etcd_ionice_priority: "0" # Highest priority within class

  tasks:
    - name: Set connection to use tailscale IP if available
      set_fact:
        ansible_host: "{{ tailscale_ip }}"
      when: tailscale_ip is defined and tailscale_ip != ''

    - name: Create etcd user
      user:
        name: "{{ etcd_user }}"
        system: yes
        shell: /bin/false
        home: "{{ etcd_data_dir }}"
        createhome: no

    - name: Create etcd directories
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ etcd_user }}"
        group: "{{ etcd_group }}"
        mode: "0700"
      loop:
        - "{{ etcd_data_dir }}"
        - "{{ etcd_wal_dir }}"
        - /etc/etcd
        - /var/lib/etcd/ssl

    - name: Download etcd binary
      unarchive:
        src: "https://github.com/etcd-io/etcd/releases/download/v{{ etcd_version }}/etcd-v{{ etcd_version }}-linux-amd64.tar.gz"
        dest: /tmp
        remote_src: yes
        creates: "/tmp/etcd-v{{ etcd_version }}-linux-amd64/etcd"
        extra_opts:
          - --no-same-owner
          - --no-same-permissions
      retries: 3
      delay: 5

    - name: Install etcd binaries
      copy:
        src: "/tmp/etcd-v{{ etcd_version }}-linux-amd64/{{ item }}"
        dest: "/usr/local/bin/{{ item }}"
        mode: "0755"
        owner: root
        group: root
        remote_src: yes
      loop:
        - etcd
        - etcdctl
        - etcdutl

    - name: Generate etcd configuration
      template:
        src: ../../templates/etcd.conf.j2
        dest: /etc/etcd/etcd.conf
        owner: "{{ etcd_user }}"
        group: "{{ etcd_group }}"
        mode: "0644"

    - name: Create etcd systemd service
      copy:
        content: |
          [Unit]
          Description=etcd key-value store
          Documentation=https://etcd.io
          After=network-online.target tailscaled.service
          Wants=network-online.target

          [Service]
          Type=notify
          User={{ etcd_user }}
          Group={{ etcd_group }}
          ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.conf
          Restart=on-failure
          RestartSec=5
          LimitNOFILE=65536
          StartLimitBurst=3

          # Security hardening
          NoNewPrivileges=true
          PrivateTmp=true
          ProtectSystem=strict
          ProtectHome=yes
          ReadWritePaths={{ etcd_data_dir }} {{ etcd_wal_dir }}
          ProtectKernelTunables=true
          ProtectKernelModules=true
          ProtectControlGroups=true
          RestrictRealtime=true
          RestrictNamespaces=true
          RestrictSUIDSGID=true
          PrivateDevices=true

          # Wait for Tailscale interface
          ExecStartPre=/bin/bash -c 'until ip addr show tailscale0 2>/dev/null | grep -q "inet "; do echo "Waiting for tailscale0 interface..."; sleep 1; done'

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/etcd.service
        owner: root
        group: root
        mode: "0644"

    - name: Set etcd environment for etcdctl
      copy:
        content: |
          export ETCDCTL_API=3
          export ETCDCTL_ENDPOINTS=http://localhost:{{ etcd_client_port }}
        dest: /etc/profile.d/etcd.sh
        mode: "0644"

    - name: Check if etcd cluster already exists
      shell: |
        export ETCDCTL_API=3
        /usr/local/bin/etcdctl member list 2>/dev/null || echo "no_cluster"
      register: existing_cluster
      failed_when: false
      changed_when: false

    - name: Stop etcd if running (for clean restart)
      systemd:
        name: etcd
        state: stopped
      failed_when: false
      when: existing_cluster.stdout == "no_cluster"

    - name: Clean existing etcd data for fresh cluster
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ etcd_data_dir }}/member"
        - "{{ etcd_wal_dir }}"
      when: existing_cluster.stdout == "no_cluster"

    - name: Recreate WAL directory after cleanup
      file:
        path: "{{ etcd_wal_dir }}"
        state: directory
        owner: "{{ etcd_user }}"
        group: "{{ etcd_group }}"
        mode: "0700"
      when: existing_cluster.stdout == "no_cluster"

    # Start etcd cluster formation
    - name: Start etcd on all nodes simultaneously
      systemd:
        name: etcd
        state: started
        enabled: yes
        daemon_reload: yes
      async: 300 # Allow up to 5 minutes for cluster formation
      poll: 0
      register: etcd_start
      when: existing_cluster.stdout == "no_cluster"

    - name: Wait for etcd cluster formation to complete
      async_status:
        jid: "{{ etcd_start.ansible_job_id }}"
      register: etcd_start_result
      until: etcd_start_result.finished
      retries: 60
      delay: 5
      when: existing_cluster.stdout == "no_cluster"

    - name: Ensure etcd is running on all nodes
      systemd:
        name: etcd
        state: started
        enabled: yes
      when: existing_cluster.stdout != "no_cluster"

    - name: Wait for all etcd nodes to be ready
      wait_for:
        port: "{{ etcd_client_port }}"
        host: localhost
        delay: 5
        timeout: 60

    - name: Wait for cluster to stabilize
      pause:
        seconds: 30
      run_once: true

    - name: Configure etcd for optimal WAN performance
      shell: |
        export ETCDCTL_API=3
        # Check current cluster status
        /usr/local/bin/etcdctl endpoint status --write-out=table

        # Verify network latency between nodes
        echo "Checking network latency between etcd nodes..."
        {% for host in groups['postgres_nodes'] %}
        {% if host != inventory_hostname %}
        ping -c 3 -W 1 {{ hostvars[host]['tailscale_ip'] }} | grep "avg" || true
        {% endif %}
        {% endfor %}
      register: etcd_perf_check
      changed_when: false
      run_once: true

    - name: Verify etcd cluster members
      shell: |
        export ETCDCTL_API=3
        /usr/local/bin/etcdctl member list
      register: etcd_members
      changed_when: false
      run_once: true

    - name: Verify etcd cluster health
      shell: |
        export ETCDCTL_API=3
        /usr/local/bin/etcdctl endpoint health --endpoints={{ groups['postgres_nodes'] | map('extract', hostvars, 'tailscale_ip') | map('regex_replace', '$', ':2379') | join(',') }}
      register: etcd_cluster_health
      changed_when: false
      run_once: true

    - name: Create etcd health check script
      copy:
        content: |
          #!/bin/bash
          export ETCDCTL_API=3

          # Check local endpoint
          if ! /usr/local/bin/etcdctl endpoint health; then
            echo "ERROR: Local etcd endpoint is unhealthy"
            exit 1
          fi

          # Check cluster status
          if ! /usr/local/bin/etcdctl endpoint status --write-out=table; then
            echo "ERROR: Cannot get cluster status"
            exit 1
          fi

          # Check for leader
          leader_count=$(/usr/local/bin/etcdctl endpoint status --write-out=json | jq '[.[] | select(.Status.leader == true)] | length')
          if [ "$leader_count" -ne 1 ]; then
            echo "ERROR: Expected 1 leader, found $leader_count"
            exit 1
          fi

          # Check database size (warn if > 1GB)
          db_size=$(/usr/local/bin/etcdctl endpoint status --write-out=json | jq '.[0].Status.dbSize')
          if [ "$db_size" -gt 1073741824 ]; then
            echo "WARNING: Database size is large: $(($db_size / 1024 / 1024))MB"
          fi

          echo "etcd cluster is healthy"
          exit 0
        dest: /usr/local/bin/etcd-health-check
        mode: "0755"

    - name: Create etcd health check timer
      copy:
        content: |
          [Unit]
          Description=etcd Health Check Timer

          [Timer]
          OnBootSec=2min
          OnUnitActiveSec=5min

          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/etcd-health-check.timer

    - name: Create etcd health check service
      copy:
        content: |
          [Unit]
          Description=etcd Health Check
          After=etcd.service

          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/etcd-health-check
          StandardOutput=journal
          StandardError=journal
        dest: /etc/systemd/system/etcd-health-check.service

    - name: Enable and start health check timer
      systemd:
        name: etcd-health-check.timer
        enabled: yes
        state: started
        daemon_reload: yes

    - name: Display etcd cluster summary
      debug:
        msg: |
          ========================================
          etcd Cluster Summary
          ========================================
          Node: {{ inventory_hostname }}
          Client URL: http://{{ tailscale_ip }}:{{ etcd_client_port }}
          Peer URL: http://{{ tailscale_ip }}:{{ etcd_peer_port }}

          WAN Tuning Applied:
          - Heartbeat interval: 100ms
          - Election timeout: 500ms
          - Snapshot count: 5000
          - WAL flush frequency: 100ms
          - gRPC keepalive: 10s

          Cluster Members:
          {{ etcd_members.stdout }}

          Cluster Health:
          {{ etcd_cluster_health.stdout }}

          Network Latency Check:
          {{ etcd_perf_check.stdout }}
          ========================================

- name: Install Confd on application nodes for dynamic pgpool-II configuration
  hosts: nomad_clients
  become: yes
  vars:
    confd_version: "0.16.0"
    etcd_client_port: 2379

  tasks:
    - name: Install etcd-client for testing
      apt:
        name: etcd-client
        state: present
        update_cache: yes

    - name: Download and install Confd
      get_url:
        url: "https://github.com/kelseyhightower/confd/releases/download/v{{ confd_version }}/confd-{{ confd_version }}-linux-amd64"
        dest: /usr/local/bin/confd
        owner: root
        group: root
        mode: "0755"

    - name: Create Confd directories
      file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop:
        - /etc/confd
        - /etc/confd/conf.d
        - /etc/confd/templates

    - name: Create Confd configuration
      copy:
        content: |
          backend = "etcdv3"
          confdir = "/etc/confd"
          log-level = "info"
          interval = 10
          noop = false

          # etcd backend configuration
          nodes = [
          {% for host in groups['postgres_nodes'] %}
            "http://{{ hostvars[host]['tailscale_ip'] }}:{{ etcd_client_port }}"{% if not loop.last %},{% endif %}
          {% endfor %}
          ]

          # Remove prefix restriction to watch all etcd keys
          # prefix = "/service/proposalsapp"
        dest: /etc/confd/confd.toml
        owner: root
        group: root
        mode: "0644"

    - name: Create pgpool resource configuration for Confd
      copy:
        content: |
          [template]
          src = "pgpool.conf.tmpl"
          dest = "/etc/pgpool2/pgpool.conf"
          owner = "postgres"
          group = "postgres"
          mode = "0644"

          # Watch Patroni keys in etcd
          keys = [
            "/service/proposalsapp/leader",
            "/service/proposalsapp/members",
            "/local/datacenter",
            "/local/ips",
            "/pgcat",
          ]

          # Reload pgpool after config update
          # Only reload if pgpool is running, otherwise just skip
          reload_cmd = "systemctl is-active --quiet pgpool && pgpool reload || true"
        dest: /etc/confd/conf.d/pgpool.toml
        owner: root
        group: root
        mode: "0644"

    - name: Create Confd systemd service
      copy:
        content: |
          [Unit]
          Description=Confd
          Documentation=https://github.com/kelseyhightower/confd
          After=network.target etcd.service
          Wants=network-online.target

          [Service]
          Type=simple
          ExecStart=/usr/local/bin/confd -config-file /etc/confd/confd.toml
          Restart=always
          RestartSec=5
          StandardOutput=journal
          StandardError=journal

          # Security hardening
          NoNewPrivileges=true
          PrivateTmp=true
          ProtectSystem=strict
          ProtectHome=true
          ReadWritePaths=/etc/pgpool2

          # Resource limits
          LimitNOFILE=65536

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/confd.service
        owner: root
        group: root
        mode: "0644"

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Wait for etcd to be available from app nodes
      wait_for:
        host: "{{ hostvars[groups['postgres_nodes'][0]]['tailscale_ip'] }}"
        port: "{{ etcd_client_port }}"
        timeout: 60
      delegate_to: "{{ inventory_hostname }}"

    - name: Test etcd connectivity from app nodes
      shell: |
        etcdctl --endpoints="{% for host in groups['postgres_nodes'] %}http://{{ hostvars[host]['tailscale_ip'] }}:{{ etcd_client_port }}{% if not loop.last %},{% endif %}{% endfor %}" \
                endpoint health
      register: etcd_health_check
      changed_when: false

    - name: Display etcd connectivity test
      debug:
        msg: "{{ etcd_health_check.stdout_lines }}"

    - name: Enable Confd service (will start after pgpool template is deployed)
      systemd:
        name: confd
        enabled: yes
        state: stopped # Will be started by pgpool playbook after template is in place
